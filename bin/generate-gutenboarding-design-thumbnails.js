#!/usr/bin/env node
/**
 * Generate static design screenshot thumbnails for Gutenboarding
 * Until we can generate tall screenshots on the fly with mshots:
 * https://github.com/Automattic/mShots/issues/16
 * https://github.com/Automattic/wp-calypso/issues/40564
 *
 * SETUP:
 *
 * Ensure browser is installed by running `node ./bin/install-gutenboarding-design-thumbnails-dependencies.js`
 * Warning: this will remove your dist and node modules directories, and reinstall packages including the Chromium browser
 *
 * GENERATE THUMBNAILS:
 *
 * `node ./bin/generate-gutenboarding-design-thumbnails.js`
 * or
 * `node ./bin/generate-gutenboarding-design-thumbnails.js all`
 * `node ./bin/generate-gutenboarding-design-thumbnails.js mag16`
 * `node ./bin/generate-gutenboarding-design-thumbnails.js es`
 * `node ./bin/generate-gutenboarding-design-thumbnails.js fr,de,zh-cn`
 *
 * We should bump the version query param on the image src to cache bust the images too in client/landing/gutenboarding/available-designs.ts
 *
 * To check the results, take a look at http://calypso.localhost:3000/new/design and the output folder static/images
 *
 */

const fs = require( 'fs' );
const puppeteer = require( 'puppeteer' );
const GIFEncoder = require( 'gifencoder' );
const PNG = require( 'png-js' );

const wpUrl = require( '@wordpress/url' );
const designs = require( '../client/landing/gutenboarding/available-designs-config.json' );
const screenshotsBasePath = './static/images/design-screenshots'; // Folder to store output images
const config = require( '../client/server/config/index.js' );
const mag16 = config( 'magnificent_non_en_locales' ) || [];

// image output variables
const viewportHeight = 800; // Browser height for capturing the screenshot
const viewportScaleFactor = 1; // Browser pixel density for capturing the screenshot
const viewportWidth = 1280; // Browser width for capturing the screenshot

const designsEndpoint = 'https://public-api.wordpress.com/rest/v1/template/demo/';

const inputSlugs = ( process.argv[ 2 ] || '' )
	.split( ',' )
	.filter( ( potentialSlug ) => mag16.includes( potentialSlug ) );

const themeFilter = typeof process.argv[ 3 ] === 'string' ? RegExp( process.argv[ 3 ] ) : /.*/;

// For convenience:
// replace an 'all' input with the mag 16
// accept an empty locale input and replacefor convenience
const specialCaseArguments = {
	all: [ '', ...config( 'magnificent_non_en_locales' ) ],
	en: [ '' ],
	mag16: config( 'magnificent_non_en_locales' ),
};

const localeSlugs = inputSlugs.length
	? specialCaseArguments[ inputSlugs[ 0 ] ] || inputSlugs
	: [ '' ];

const getDesignUrl = ( design, language = 'en' ) => {
	return wpUrl.addQueryArgs(
		`${ designsEndpoint }${ encodeURIComponent( design.theme ) }/${ encodeURIComponent(
			design.template
		) }`,
		{
			font_base: design.fonts.base,
			font_headings: design.fonts.headings,
			site_title: design.title,
			...( language && language !== 'en' && { language } ),
		}
	);
};

async function run() {
	if (
		( typeof designs === 'object' && ! Array.isArray( designs.featured ) ) ||
		! designs.featured
	) {
		console.error(
			'Could not find any featured designs. Check the regex or the available-designs.ts file'
		);
		return;
	}
	console.log( `Processing ${ designs.featured.length } designs...` );
	console.log( `for each of ${ localeSlugs.join( ', ' ) } (${ localeSlugs.length } locales)...` );

	const browser = await puppeteer.launch( {
		headless: true,
		timeout: 60000,
		ignoreHTTPSErrors: true,
		// product:"firefox"
	} );

	// const page = browser.init()
	const page = await browser.newPage();
	await page.setViewport( {
		width: viewportWidth,
		height: viewportHeight,
		scaleFactor: viewportScaleFactor,
	} );
	await page.setCacheEnabled( false );
	// await page.setRequestInterception( true ); // This lets us filter requests generated by the page
	await page._client.send( 'Page.setDownloadBehavior', { behavior: 'deny' } );

	// If we run even 2 capture-website/puppeteer/chromium instances
	// concurrently things get very unstable, so we're going to use a good
	// old-fashioned for loop to keep things serialized.
	for ( let ii = 0; ii < localeSlugs.length; ii++ ) {
		const locale = localeSlugs[ ii ];
		const screenshotsPath = locale ? `${ screenshotsBasePath }/${ locale }` : screenshotsBasePath;
		fs.mkdirSync( screenshotsPath, { recursive: true } );
		for ( let i = 0; i < designs.featured.length; i++ ) {
			const design = designs.featured[ i ];

			const url = getDesignUrl( design, locale );
			const fileBase = `${ design.slug }_${ design.template }_${ design.theme }`;
			// const file = `${ screenshotsPath }/${ fileBase }`;

			if ( ! url.match( themeFilter ) ) {
				continue;
			}

			const response = await page.goto( url, { waitUntil: 'networkidle0' } );

			if ( ! ( response && response.ok() ) ) {
				console.error( 'error: page did not load.' );
				continue;
			}

			const scrollHeight = await page.evaluate( () => document.body.scrollHeight );

			const screenshotOptions = {
				fullPage: false,
				type: 'png',
			};

			const animating = true;
			const scrollPerFrame = 50;

			if ( ! animating ) {
				// Hide the masthead if we're stitching together a tall image
				await page.addStyleTag( { content: 'header#masthead{display: none}' } );
			}

			const screenshots = [];

			const encoder = new GIFEncoder( viewportWidth, viewportHeight );
			encoder.createWriteStream().pipe( fs.createWriteStream( `${ fileBase }.gif` ) );
			console.log( `Saving animation to ${ fileBase }.gif` );

			// setting gif encoder
			encoder.start();
			encoder.setRepeat( -1 );
			encoder.setDelay( 100 );
			encoder.setQuality( 5 ); // default

			const appendFrameToGif = encoder.addFrame.bind( encoder );

			// screenshot -> Promise( )

			const decodePNG = ( screenshot ) =>
				new Promise( ( resolve ) =>
					new PNG( screenshot ).decode( ( result ) => resolve( result ) )
				);

			try {
				for (
					let remaining = scrollHeight, screenshotIndex = 0;
					0 <= remaining;
					remaining -= scrollPerFrame, screenshotIndex++
				) {
					await page.evaluate(
						( scrollAmount ) => window.scrollBy( 0, scrollAmount ),
						scrollPerFrame
					);

					// Uncomment to debug intermediate frames:
					// const fileName = `${ file }_${ String( screenshotIndex ).padStart( 2, 0 ) }.jpg`;
					// console.log( 'creating', fileName );
					const screenshot = await page.screenshot( {
						// path: fileName,
						...screenshotOptions,
					} );

					await decodePNG( screenshot ).then( appendFrameToGif );

					screenshots.push( screenshot );
				}
			} catch ( e ) {
				if (
					typeof e.message === 'string' &&
					e.message.includes( 'Could not find browser revision' )
				) {
					console.error(
						'\n\nPlease run `(cd node_modules/puppeteer; PUPPETEER_SKIP_DOWNLOAD= yarn install)` to install the chromium binaries required for this script and then try again.'
					);
					process.exit( 1 );
				}
				console.error( 'screenshot error:', e );
			}

			// Scroll back up
			await screenshots.reduceRight(
				( previousPromise, screenshot ) =>
					previousPromise.then( () => decodePNG( screenshot ) ).then( appendFrameToGif ),
				Promise.resolve()
			);

			// Add a pause at the top:
			if ( typeof screenshots[ 0 ] !== 'undefined' ) {
				const decodedFirstFrame = await decodePNG( screenshots[ 0 ] );
				appendFrameToGif( decodedFirstFrame );
				appendFrameToGif( decodedFirstFrame );
				appendFrameToGif( decodedFirstFrame );
				appendFrameToGif( decodedFirstFrame );
			}

			encoder.finish();
			// We could still capture normal webp/jpg screenshots here.
		}

		console.log( 'closing page' );
		await page.close();
	}

	console.log( 'Done!' );
}

run().then( () => process.exit( 0 ) );
