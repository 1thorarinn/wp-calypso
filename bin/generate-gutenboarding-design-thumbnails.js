#!/usr/bin/env node
/**
 * Generate static design screenshot thumbnails for Gutenboarding
 * Until we can generate tall screenshots on the fly with mshots:
 * https://github.com/Automattic/mShots/issues/16
 * https://github.com/Automattic/wp-calypso/issues/40564
 *
 * SETUP:
 *
 * Ensure browser is installed by running `node ./bin/install-gutenboarding-design-thumbnails-dependencies.js`
 * Warning: this will remove your dist and node modules directories, and reinstall packages including the Chromium browser
 *
 * GENERATE THUMBNAILS:
 *
 * `node ./bin/generate-gutenboarding-design-thumbnails.js`
 * or
 * `node ./bin/generate-gutenboarding-design-thumbnails.js all`
 * `node ./bin/generate-gutenboarding-design-thumbnails.js mag16`
 * `node ./bin/generate-gutenboarding-design-thumbnails.js es`
 * `node ./bin/generate-gutenboarding-design-thumbnails.js fr,de,zh-cn`
 *
 * We should bump the version query param on the image src to cache bust the images too in client/landing/gutenboarding/available-designs.ts
 *
 * To check the results, take a look at http://calypso.localhost:3000/new/design and the output folder static/images
 *
 */

const fs = require( 'fs' );
const captureWebsite = require( 'capture-website' );
const sharp = require( 'sharp' );
const wpUrl = require( '@wordpress/url' );
const designs = require( '../client/landing/gutenboarding/available-designs-config.json' );
const screenshotsBasePath = './static/images/design-screenshots'; // Folder to store output images

const puppeteer = require( 'puppeteer' );

const config = require( '../client/server/config/index.js' );
const mag16 = config( 'magnificent_non_en_locales' ) || [];

// image output variables
const captureMaxHeight = 2072; // Cap long pages to  this pixel height when capturing
const outputWidth = 900; // Outputted file width
const viewportHeight = 800; // Browser height for capturing the screenshot
const viewportScaleFactor = 1; // Browser pixel density for capturing the screenshot
const viewportWidth = 1280; // Browser width for capturing the screenshot

const designsEndpoint = 'https://public-api.wordpress.com/rest/v1/template/demo/';

const inputSlugs = ( process.argv[ 2 ] || '' )
	.split( ',' )
	.filter( ( potentialSlug ) => mag16.includes( potentialSlug ) );

// For convenience:
// replace an 'all' input with the mag 16
// accept an empty locale input and replacefor convenience
const specialCaseArguments = {
	all: [ '', ...config( 'magnificent_non_en_locales' ) ],
	en: [ '' ],
	mag16: config( 'magnificent_non_en_locales' ),
};

const localeSlugs = inputSlugs.length
	? specialCaseArguments[ inputSlugs[ 0 ] ] || inputSlugs
	: [ '' ];

const getDesignUrl = ( design, language = 'en' ) => {
	return wpUrl.addQueryArgs(
		`${ designsEndpoint }${ encodeURIComponent( design.theme ) }/${ encodeURIComponent(
			design.template
		) }`,
		{
			font_base: design.fonts.base,
			font_headings: design.fonts.headings,
			site_title: design.title,
			...( language && language !== 'en' && { language } ),
		}
	);
};

async function run() {
	if (
		( typeof designs === 'object' && ! Array.isArray( designs.featured ) ) ||
		! designs.featured
	) {
		console.error(
			'Could not find any featured designs. Check the regex or the available-designs.ts file'
		);
		return;
	}
	console.log( `Processing ${ designs.featured.length } designs...` );
	console.log( `for each of ${ localeSlugs.join( ', ' ) } (${ localeSlugs.length } locales)...` );

	const browser = await puppeteer.launch( {
		headless: true,
		timeout: 60000,
		ignoreHTTPSErrors: true,
		// product:"firefox"
	} );
	// const page = browser.init()
	const page = await browser.newPage();
	await page.setViewport( {
		width: viewportWidth,
		height: viewportHeight,
		scaleFactor: viewportScaleFactor,
	} );
	await page.setCacheEnabled( false );
	// await page.setRequestInterception( true ); // This lets us filter requests generated by the page
	await page._client.send( 'Page.setDownloadBehavior', { behavior: 'deny' } );

	// If we run even 2 capture-website/puppeteer/chromium instances
	// concurrently things get very unstable, so we're going to use a good
	// old-fashioned for loop to keep things serialized.
	for ( let ii = 0; ii < localeSlugs.length; ii++ ) {
		const locale = localeSlugs[ ii ];
		const screenshotsPath = locale ? `${ screenshotsBasePath }/${ locale }` : screenshotsBasePath;
		fs.mkdirSync( screenshotsPath, { recursive: true } );
		for ( let i = 0; i < designs.featured.length; i++ ) {
			const design = designs.featured[ i ];

			const url = getDesignUrl( design, locale );
			const file = `${ screenshotsPath }/${ design.slug }_${ design.template }_${ design.theme }`;

			if ( ! url.match( /reynolds/ ) ) {
				continue;
			}

			// page loaded?
			console.log( 'going to url' );
			const response = await page.goto( url, { waitUntil: 'networkidle0' } );
			// console.log( 'response:', response );
			console.log( 'response.ok():', response.ok() );
			if ( ! ( response && response.ok() ) ) {
				console.log( 'error: page did not load.' );
			}

			const scrollHeight = await page.evaluate( () => document.body.scrollHeight );
			console.log( 'scrollHeight:', scrollHeight );
			const content = await page.content();
			// console.log( 'content:', content );
			// await page.waitFor( 2000 );

			console.log( `Taking screenshot of ${ url }` );
			console.log( `Saving to ${ file }.jpg` );

			const screenshotOptions = {
				fullPage: false,
				type: 'jpeg',
				quality: 90,
				// width: viewportWidth,
				// height: viewportHeight,
				// clip: {
				// 	x:0,
				// 	y:0,
				// 	width: viewportWidth,
				// 	height: captureMaxHeight,
				// },
			};

			// const screenshot = await page.screenshot( {
			// 	path: `${ file }.jpg`,
			// 	...screenshotOptions,
			// } );

			// Scroll:
			const animating = true;
			const scrollPerFrame = animating ? 100 : viewportHeight;

			if ( ! animating ) {
				// Hide the masthead if we're stitching together a tall image
				await page.addStyleTag( { content: 'header#masthead{display: none}' } );
			}

			const screenshots = [];

			try {
				for (
					let remaining = scrollHeight, i = 0;
					0 <= remaining;
					remaining -= scrollPerFrame, i++
				) {
					await page.evaluate(
						( scrollAmount ) => window.scrollBy( 0, scrollAmount ),
						scrollPerFrame
					);
					const fileName = `${ file }_${ String( i ).padStart( 2, 0 ) }.jpg`;
					console.log( 'creating', fileName );
					screenshots.push(
						await page.screenshot( {
							path: fileName,
							// clip: {
							// 	x:0,
							// 	// y: scrollHeight - remaining,
							// 	y: 0,
							// 	width: viewportWidth,
							// 	// height: Math.min( remaining, viewportHeight ),
							// 	height: viewportHeight,
							// },
							...screenshotOptions,
						} )
					);
				}
			} catch ( e ) {
				if (
					typeof e.message === 'string' &&
					e.message.includes( 'Run "npm install" or "yarn install" to download a browser binary.' )
				) {
					console.error(
						'\n\nPlease run `PUPPETEER_SKIP_DOWNLOAD= yarn install` to install the chromium binaries required for this script and then try again.'
					);
					process.exit( 1 );
				}
				console.log( 'screenshot error:', e );
			}

			continue;

			// Fix `reynolds_rockfield2_rockfield.jpg` first section becoming super tall
			// @TODO: fix at the source since this will be an issue with mshots API, too.
			const styles =
				design.slug === 'reynolds'
					? [ `.wp-block-cover, .wp-block-cover-image { min-height: ${ viewportHeight }px; }` ]
					: [];

			console.log( `Taking screenshot of ${ url }` );

			// let screenshot;
			// 	screenshot = await captureWebsite.buffer( url, {
			// 		// fullPage: true,
			// 		scaleFactor: viewportScaleFactor,
			// 		width: viewportWidth,
			// 		height: viewportHeight,
			// 		launchOptions: { headless: true, timeout: 30000, ignoreHTTPSErrors: true },
			// 		defaultBackground: false,
			// 		styles,
			// 		timeout: 120,
			// 		type: 'png',
			// 		// generate appropriate clip parameters
			// 		element: '#page',
			// 	} );

			// stiching inspiration: https://github.com/lovell/sharp/issues/405#issuecomment-208033263

			[ 'webp', 'jpg' ].forEach( async ( extension ) => {
				return;
				console.log( `Resizing and saving to ${ file }.${ extension }` );
				let image = await sharp( screenshot, { fit: 'max' } );
				console.log( 'image:', image );
				return (
					image &&
					( await image
						.metadata()
						.then( ( metadata ) => {
							console.log( 'metadata:', metadata );
							console.log(
								'Math.min( metadata.height, captureMaxHeight * viewportScaleFactor ):',
								Math.min( metadata.height, captureMaxHeight * viewportScaleFactor )
							);
							// image = image
							// 	.extract( {
							// 		// Ensure we're not extracting taller area than screenshot actaully is
							// 		height: Math.min( metadata.height, captureMaxHeight * viewportScaleFactor ),
							// 		left: 0,
							// 		top: 0,
							// 		width: metadata.width,
							// 	} )
							// 	.resize( outputWidth );
							if ( extension === 'webp' ) {
								image = image.webp(); // default quality is 80
							} else {
								image = image.jpeg( { quality: 72 } );
							}
							image.toFile( `${ file }.${ extension }` );
						} )
						.catch( ( error ) => console.log( error ) ) )
				);
			} );
		}

		console.log( 'closing page' );
		await page.close();
	}

	console.log( 'Done!' );
}

run().then( () => process.exit( 0 ) );

async function autoScroll( page ) {
	await page.evaluate( async () => {
		await new Promise( ( resolve, reject ) => {
			var totalHeight = 0;
			var distance = 100;
			var timer = setInterval( () => {
				var scrollHeight = document.body.scrollHeight;
				window.scrollBy( 0, distance );
				totalHeight += distance;

				if ( totalHeight >= scrollHeight ) {
					clearInterval( timer );
					resolve();
				}
			}, 100 );
		} );
	} );
}
